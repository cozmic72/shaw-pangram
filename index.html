<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shavian Pangram & Anagram Solver</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <button id="burger-menu" class="burger-menu" aria-label="Menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <h1>êëñêë±êëùêëæêëØ Pangram & Anagram Solver</h1>
            <p class="subtitle">Find perfect pangrams or solve anagrams using the Shavian alphabet</p>

            <!-- Burger Menu Dropdown -->
            <div id="menu-dropdown" class="menu-dropdown hidden">
                <button id="menu-about" class="menu-item">About</button>
                <button id="menu-solutions" class="menu-item">Saved Solutions</button>
                <button id="menu-share" class="menu-item">Share Current State</button>
            </div>
        </header>

        <!-- About Dialog -->
        <div id="about-dialog" class="dialog-overlay hidden">
            <div class="dialog">
                <button class="dialog-close">&times;</button>
                <div id="about-content"></div>
            </div>
        </div>

        <!-- Solutions Dialog -->
        <div id="solutions-dialog" class="dialog-overlay hidden">
            <div class="dialog">
                <button class="dialog-close">&times;</button>
                <h2>Saved Solutions</h2>
                <div id="solutions-list" class="solutions-list"></div>
                <button id="save-current" class="save-current-btn">Save Current Solution</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    <strong>Alphabet</strong>
                </label>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="alphabet" value="shavian" id="alphabet-shavian" checked>
                        <span>Shavian</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="alphabet" value="roman" id="alphabet-roman">
                        <span>Roman</span>
                    </label>
                </div>
            </div>

            <div class="control-group">
                <label for="target-letters">
                    <strong>Target Word or Phrase</strong>
                    <span class="hint" id="target-letters-hint">(leave empty for all 48 Shavian letters, click to remove)</span>
                </label>
                <div
                    id="target-letters"
                    class="editable-input"
                    contenteditable="true"
                    data-placeholder="êëêêëëêëíêëìêëîêëï or leave empty"
                ></div>
            </div>

            <div class="control-group">
                <label for="starter-words">
                    <strong>Solve Words</strong>
                    <span class="hint">(optional - click to remove)</span>
                </label>
                <div
                    id="starter-words"
                    class="editable-input"
                    contenteditable="true"
                    data-placeholder="êëêêëë êëíêëì"
                ></div>
            </div>

            <div class="control-group">
                <label for="exclude-words">
                    <strong>Exclude Words</strong>
                    <span class="hint">(optional - click to remove)</span>
                </label>
                <div
                    id="exclude-words"
                    class="editable-input"
                    contenteditable="true"
                    data-placeholder="êëîêëï êëñêëó"
                ></div>
            </div>

        </div>

        <div class="results-section">
            <h2>Solutions: <span id="solution-count">0</span></h2>
            <div id="exact-match-actions" class="exact-match-actions hidden">
                <button id="save-exact-match" class="exact-match-btn">üíæ Save</button>
                <button id="share-exact-match" class="exact-match-btn">üîó Share</button>
            </div>
            <div id="results-container" class="results-container">
                <div class="placeholder">Enter parameters and click "Solve" to begin</div>
            </div>
            <div id="loading-indicator" class="loading-indicator">
                Loading more solutions...
            </div>
        </div>
    </div>

    <footer class="footer">
        &copy; 2025 joro.io
    </footer>

    <script src="pangram-solver.js"></script>
    <script>
        let solver = null;
        let allSolutions = [];
        let displayedCount = 0;
        const BATCH_SIZE = 1000;
        let totalSolutionsFound = 0;
        let currentParams = null; // Store current solve parameters

        // DOM elements
        const targetLetters = document.getElementById('target-letters');
        const starterWords = document.getElementById('starter-words');
        const excludeWords = document.getElementById('exclude-words');
        const resultsContainer = document.getElementById('results-container');
        const solutionCountEl = document.getElementById('solution-count');
        const loadingIndicator = document.getElementById('loading-indicator');
        const alphabetShavian = document.getElementById('alphabet-shavian');
        const alphabetRoman = document.getElementById('alphabet-roman');
        const targetLettersHint = document.getElementById('target-letters-hint');
        const exactMatchActions = document.getElementById('exact-match-actions');
        const saveExactMatchBtn = document.getElementById('save-exact-match');
        const shareExactMatchBtn = document.getElementById('share-exact-match');

        // LocalStorage keys - get alphabet-specific keys
        function getStorageKeys(alphabet) {
            return {
                targetLetters: `pangram_${alphabet}_target_letters`,
                starterWords: `pangram_${alphabet}_starter_words`,
                excludeWords: `pangram_${alphabet}_exclude_words`
            };
        }

        const ALPHABET_KEY = 'pangram_alphabet';

        // Get current alphabet
        function getCurrentAlphabet() {
            return alphabetRoman.checked ? 'roman' : 'shavian';
        }

        // Undo/Redo Manager
        class UndoManager {
            constructor() {
                this.history = [];
                this.currentIndex = -1;
                this.maxHistory = 50; // Keep last 50 snapshots
            }

            takeSnapshot() {
                // Create snapshot of current state
                const snapshot = {
                    alphabet: getCurrentAlphabet(),
                    targetLetters: getTextContent(targetLetters, false),
                    starterWords: getTextContent(starterWords, false),
                    excludeWords: getTextContent(excludeWords, false)
                };

                // Remove any future history if we're not at the end
                if (this.currentIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentIndex + 1);
                }

                // Add snapshot
                this.history.push(snapshot);

                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                } else {
                    this.currentIndex++;
                }
            }

            canUndo() {
                return this.currentIndex > 0;
            }

            canRedo() {
                return this.currentIndex < this.history.length - 1;
            }

            undo() {
                if (!this.canUndo()) return false;

                this.currentIndex--;
                this.restoreSnapshot(this.history[this.currentIndex]);
                return true;
            }

            redo() {
                if (!this.canRedo()) return false;

                this.currentIndex++;
                this.restoreSnapshot(this.history[this.currentIndex]);
                return true;
            }

            restoreSnapshot(snapshot) {
                // Restore alphabet if different
                if (snapshot.alphabet !== getCurrentAlphabet()) {
                    if (snapshot.alphabet === 'roman') {
                        alphabetRoman.checked = true;
                    } else {
                        alphabetShavian.checked = true;
                    }
                    updateAlphabetHint();
                }

                // Restore fields
                targetLetters.textContent = snapshot.targetLetters || '';
                setTextContent(starterWords, snapshot.starterWords);
                setTextContent(excludeWords, snapshot.excludeWords);

                // Ensure editable spaces
                ensureEditableSpace(targetLetters);
                ensureEditableSpace(starterWords);
                ensureEditableSpace(excludeWords);

                // Validate
                const availableLetters = getTextContent(targetLetters, false);
                revalidateChips(starterWords, availableLetters);

                // Save to localStorage
                saveState();

                // Trigger solve
                checkAndTriggerSolve();
            }
        }

        const undoManager = new UndoManager();

        // Extract punctuation from text
        function extractPunctuation(text) {
            const leadingMatch = text.match(/^([^\p{L}\p{N}]+)/u);
            const trailingMatch = text.match(/([^\p{L}\p{N}]+)$/u);

            const leading = leadingMatch ? leadingMatch[1] : '';
            const trailing = trailingMatch ? trailingMatch[1] : '';
            const core = text.slice(leading.length, text.length - trailing.length);

            return { leading, core, trailing };
        }

        // Get text content from editable div (excluding chips)
        function getTextContent(element, stripPunctuation = false) {
            let text = '';
            for (const node of element.childNodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    // Filter out zero-width spaces
                    const content = node.textContent.replace(/\u200B/g, '');
                    text += content;
                } else if (node.classList && node.classList.contains('word-chip')) {
                    // Get text from chip's data attribute
                    const chipText = node.dataset.text || '';
                    if (stripPunctuation) {
                        // Extract just the core word without punctuation
                        const { core } = extractPunctuation(chipText);
                        text += core + ' ';
                    } else {
                        // Keep punctuation
                        text += chipText + ' ';
                    }
                } else if (node.classList && node.classList.contains('editable-span')) {
                    // Get text from editable span, filtering zero-width spaces
                    const content = node.textContent.replace(/\u200B/g, '');
                    text += content;
                }
            }
            return text.trim();
        }

        // Validate a word against available letters and other words in the same element
        function validateWord(word, availableLetters, element = null, skipChip = null) {
            // Strip punctuation for validation
            const { core } = extractPunctuation(word);
            if (!core) return null; // Empty word

            // Get available letters (or all letters for current alphabet if empty)
            let letters = availableLetters.trim();
            if (!letters) {
                const alphabet = getCurrentAlphabet();
                if (alphabet === 'roman') {
                    letters = 'abcdefghijklmnopqrstuvwxyz';
                } else {
                    // All 48 Shavian letters
                    letters = '';
                    for (let i = 0x10450; i < 0x10480; i++) {
                        letters += String.fromCodePoint(i);
                    }
                }
            }

            // Remove whitespace
            letters = letters.replace(/\s+/g, '');

            // Count available letters
            const letterCounts = new Map();
            for (const letter of letters) {
                letterCounts.set(letter, (letterCounts.get(letter) || 0) + 1);
            }

            // If we have an element, subtract letters used by other chips
            const usedByWord = new Map(); // Track which word used each letter
            if (element) {
                try {
                    const existingChips = element.querySelectorAll('.word-chip');
                    for (const chip of existingChips) {
                        if (chip === skipChip) continue; // Skip the chip we're validating

                        const chipText = chip.dataset.text || '';
                        if (!chipText) continue;

                        const { core: chipCore } = extractPunctuation(chipText);
                        if (!chipCore) continue;

                        for (const letter of chipCore) {
                            const count = letterCounts.get(letter) || 0;
                            if (count > 0) {
                                letterCounts.set(letter, count - 1);
                                // Only track first word that uses this letter
                                if (!usedByWord.has(letter)) {
                                    usedByWord.set(letter, chipCore);
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error processing existing chips:', err);
                }
            }

            // Check if current word can be formed with remaining letters
            const wordLetters = [...core];
            for (const letter of wordLetters) {
                const count = letterCounts.get(letter) || 0;
                if (count === 0) {
                    const usedBy = usedByWord.get(letter);
                    if (usedBy) {
                        return `Letter '${letter}' not available, used in '${usedBy}'`;
                    } else {
                        return `Letter '${letter}' not in target letters`;
                    }
                }
                letterCounts.set(letter, count - 1);
            }

            return null; // No error
        }

        // Set text content to editable div with chips
        function setTextContent(element, text, separator = /[\s,]+/) {
            const words = text.trim().split(separator).filter(w => w);
            element.innerHTML = '';

            words.forEach((word, index) => {
                const chip = createChip(word);
                element.appendChild(chip);
                // No spaces needed - CSS handles spacing between chips
            });
        }

        // Create a chip element
        function createChip(text, allowMove = true, errorMessage = null) {
            const chip = document.createElement('span');
            chip.className = 'word-chip';
            if (errorMessage) {
                chip.classList.add('error');
                chip.title = errorMessage;
            }
            chip.contentEditable = 'false';
            chip.draggable = true;

            // Add word text
            const textSpan = document.createElement('span');
            textSpan.className = 'chip-text';
            textSpan.textContent = text;
            chip.appendChild(textSpan);

            // Add remove button
            const removeBtn = document.createElement('span');
            removeBtn.className = 'chip-remove';
            removeBtn.innerHTML = '√ó';
            removeBtn.title = 'Remove';
            chip.appendChild(removeBtn);

            // Click remove button to delete
            removeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                undoManager.takeSnapshot();
                const parent = chip.parentElement;
                chip.remove();
                if (parent) {
                    ensureEditableSpace(parent);
                    // Revalidate if this is solve words
                    if (parent === starterWords) {
                        const availableLetters = getTextContent(targetLetters, false);
                        revalidateChips(starterWords, availableLetters);
                    }
                }
                saveState();
                checkAndTriggerSolve();
            });

            // Store text for easier access
            chip.dataset.text = text;

            // Drag events
            chip.addEventListener('dragstart', (e) => {
                console.log('[Drag] Start:', text, 'allowMove:', allowMove);
                // Input chips can be moved (reordered), result chips can only be copied
                e.dataTransfer.effectAllowed = allowMove ? 'move' : 'copy';
                e.dataTransfer.setData('text/plain', text);
                e.dataTransfer.setData('chip-id', chip.dataset.chipId = Date.now() + '-' + Math.random());
                e.dataTransfer.setData('allow-move', allowMove ? 'true' : 'false');
                chip.classList.add('dragging');
            });

            chip.addEventListener('dragend', (e) => {
                console.log('[Drag] End:', text, 'dropEffect:', e.dataTransfer.dropEffect);
                chip.classList.remove('dragging');

                // Don't do anything here - removal/reordering is handled in drop event
                // The chip is already in the right place from dragover
            });

            return chip;
        }

        // Load saved state from localStorage or URL parameters
        function loadState() {
            // Check for URL parameters first (sharing)
            const urlParams = new URLSearchParams(window.location.search);
            const hasUrlParams = urlParams.has('a') || urlParams.has('t') || urlParams.has('s') || urlParams.has('e') || urlParams.has('p');

            let alphabet, targetText, starterText, excludeText;

            if (hasUrlParams) {
                // Load from URL params (shared state)
                alphabet = urlParams.get('a') || 'shavian';

                // Check for compact encoded format ('p' parameter for pangrams)
                const encodedPangram = urlParams.get('p');
                if (encodedPangram) {
                    // Decode the compact pangram format
                    starterText = decodeWords(encodedPangram, alphabet);
                    targetText = '';
                    excludeText = '';
                } else {
                    // Check for encoded anagram format ('t' and 's' parameters)
                    const encodedTarget = urlParams.get('t');
                    const encodedSolve = urlParams.get('s');

                    if (encodedTarget || encodedSolve) {
                        // Decode compact anagram format
                        targetText = encodedTarget ? decodeWords(encodedTarget, alphabet) : '';
                        starterText = encodedSolve ? decodeWords(encodedSolve, alphabet) : '';
                        excludeText = '';
                    } else {
                        // Use legacy plain text format (backwards compatibility)
                        targetText = urlParams.get('t') || '';
                        starterText = urlParams.get('s') || '';
                        excludeText = urlParams.get('e') || '';
                    }
                }

                console.log('Loading state from URL:', { alphabet, targetText, starterText, excludeText });
            } else {
                // Load from localStorage (normal operation)
                alphabet = localStorage.getItem(ALPHABET_KEY) || 'shavian';
                const keys = getStorageKeys(alphabet);
                targetText = localStorage.getItem(keys.targetLetters) || '';
                starterText = localStorage.getItem(keys.starterWords) || '';
                excludeText = localStorage.getItem(keys.excludeWords) || '';
            }

            // Restore alphabet selection
            if (alphabet === 'roman') {
                alphabetRoman.checked = true;
            } else {
                alphabetShavian.checked = true;
            }
            updateAlphabetHint();

            // Target letters is plain text, not chips
            if (targetText) {
                targetLetters.textContent = targetText;
            }
            if (starterText) setTextContent(starterWords, starterText);
            if (excludeText) setTextContent(excludeWords, excludeText);

            // Validate loaded chips (only solve words need validation)
            const availableLetters = getTextContent(targetLetters, false);
            revalidateChips(starterWords, availableLetters);

            // If loaded from URL, save to localStorage for this session
            if (hasUrlParams) {
                saveState();
                // Clear URL params so refreshing doesn't reload shared state
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        // Save state to localStorage
        function saveState() {
            const alphabet = getCurrentAlphabet();
            const keys = getStorageKeys(alphabet);
            localStorage.setItem(keys.targetLetters, getTextContent(targetLetters));
            localStorage.setItem(keys.starterWords, getTextContent(starterWords));
            localStorage.setItem(keys.excludeWords, getTextContent(excludeWords));
            localStorage.setItem(ALPHABET_KEY, alphabet);
        }

        // Ensure there's always an editable span to type in
        function ensureEditableSpace(element) {
            // Check if last child is an editable span
            const lastChild = element.lastChild;
            const hasEditableSpan = lastChild &&
                                   lastChild.nodeType === Node.ELEMENT_NODE &&
                                   lastChild.classList.contains('editable-span');

            // If no children, or last child is a chip, add an editable span
            if (element.childNodes.length === 0 ||
                (lastChild && lastChild.classList && lastChild.classList.contains('word-chip'))) {
                const span = document.createElement('span');
                span.className = 'editable-span';
                span.contentEditable = 'true';
                span.textContent = '\u200B'; // Zero-width space as placeholder
                element.appendChild(span);
            }
        }

        // Handle keypresses in editable inputs
        function setupEditableInput(element, separator = /[\s,]/) {
            // Ensure there's always somewhere to click and type
            ensureEditableSpace(element);

            // Ensure element is focusable and clicking focuses the editable span
            element.addEventListener('click', (e) => {
                // If clicking on the element itself, check if we're between chips or at the beginning
                if (e.target === element) {
                    // Get click position
                    const clickX = e.clientX;

                    // Find chips near the click
                    const chips = element.querySelectorAll('.word-chip');

                    // Check if clicking before the first chip
                    if (chips.length > 0) {
                        const firstChipRect = chips[0].getBoundingClientRect();
                        if (clickX < firstChipRect.left) {
                            const newSpan = document.createElement('span');
                            newSpan.className = 'editable-span';
                            newSpan.contentEditable = 'true';
                            newSpan.textContent = '\u200B';
                            element.insertBefore(newSpan, chips[0]);

                            newSpan.focus();
                            const range = document.createRange();
                            const selection = window.getSelection();
                            range.selectNodeContents(newSpan);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            return;
                        }
                    }

                    let insertAfterChip = null;

                    for (let i = 0; i < chips.length; i++) {
                        const chip = chips[i];
                        const rect = chip.getBoundingClientRect();
                        const nextChip = chips[i + 1];

                        // Check if click is after this chip and before the next chip (or end)
                        if (clickX > rect.right) {
                            if (!nextChip || clickX < nextChip.getBoundingClientRect().left) {
                                insertAfterChip = chip;
                                break;
                            }
                        }
                    }

                    // If we found a position between chips (not at the end), insert editable span
                    if (insertAfterChip && insertAfterChip !== chips[chips.length - 1]) {
                        const newSpan = document.createElement('span');
                        newSpan.className = 'editable-span';
                        newSpan.contentEditable = 'true';
                        newSpan.textContent = '\u200B'; // Zero-width space

                        // Insert after the chip
                        insertAfterChip.parentElement.insertBefore(newSpan, insertAfterChip.nextSibling);

                        // Focus the new span
                        newSpan.focus();
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.selectNodeContents(newSpan);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        return; // Don't run default behavior
                    }
                }

                ensureEditableSpace(element);

                // If clicking on the element itself (not a chip or span), focus the editable span at the end
                if (e.target === element) {
                    const editableSpans = element.querySelectorAll('.editable-span');
                    const lastEditableSpan = editableSpans[editableSpans.length - 1];
                    if (lastEditableSpan) {
                        lastEditableSpan.focus();
                        // Place caret at end of span
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.selectNodeContents(lastEditableSpan);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            });

            element.addEventListener('keydown', (e) => {
                // Check if typing punctuation in an empty editable span - append to last chip
                // Use Unicode property to match any punctuation character
                const isPunctuation = e.key.length === 1 && /^\p{P}$/u.test(e.key);
                if (isPunctuation) {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;

                    // If we're in a text node inside an editable span, get the span
                    if (container.nodeType === Node.TEXT_NODE && container.parentElement.classList.contains('editable-span')) {
                        container = container.parentElement;
                    }

                    // Check if we're in an editable span with no text
                    if (container.classList && container.classList.contains('editable-span')) {
                        const text = container.textContent.replace(/\u200B/g, '').trim();
                        if (!text) {
                            // Find the last chip before this editable span
                            let prevSibling = container.previousSibling;
                            while (prevSibling && !prevSibling.classList?.contains('word-chip')) {
                                prevSibling = prevSibling.previousSibling;
                            }

                            if (prevSibling && prevSibling.classList.contains('word-chip')) {
                                e.preventDefault();
                                // Append punctuation to the last chip
                                const lastChip = prevSibling;
                                const oldText = lastChip.dataset.text || '';
                                const newText = oldText + e.key;
                                lastChip.dataset.text = newText;

                                // Update the chip's text content
                                const textSpan = lastChip.querySelector('.chip-text');
                                if (textSpan) {
                                    textSpan.textContent = newText;
                                }

                                // Revalidate if this is solve words
                                if (element === starterWords) {
                                    const availableLetters = getTextContent(targetLetters, false);
                                    revalidateChips(starterWords, availableLetters);
                                }

                                saveState();
                                checkAndTriggerSolve();
                                return;
                            }
                        }
                    }
                }

                // Convert text to chip on space, comma, or Enter
                if (e.key === ' ' || e.key === ',' || e.key === 'Enter') {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;
                    let cursorPos = range.startOffset;

                    // If we're in a text node inside an editable span, get the span
                    if (container.nodeType === Node.TEXT_NODE && container.parentElement.classList.contains('editable-span')) {
                        // Keep the cursor position relative to the text node
                        container = container.parentElement;
                    } else if (container.classList && container.classList.contains('editable-span')) {
                        // If directly in the span, cursor position is relative to child nodes
                        // Get actual text position
                        let textPos = 0;
                        for (let i = 0; i < cursorPos; i++) {
                            const child = container.childNodes[i];
                            if (child.nodeType === Node.TEXT_NODE) {
                                textPos += child.textContent.length;
                            }
                        }
                        cursorPos = textPos;
                    }

                    // Check if we're in an editable span
                    if (container.classList && container.classList.contains('editable-span')) {
                        const fullText = container.textContent.replace(/\u200B/g, '');

                        e.preventDefault();

                        // Take snapshot before creating chips
                        if (fullText.trim()) {
                            undoManager.takeSnapshot();
                        }

                        // Split text at cursor position
                        const beforeCursor = fullText.substring(0, cursorPos).trim();
                        const afterCursor = fullText.substring(cursorPos).trim();

                        console.log('[Space] Creating chips from:', { fullText, beforeCursor, afterCursor, cursorPos });

                        // Skip if both parts are empty or only punctuation
                        if (!beforeCursor && !afterCursor) {
                            console.log('[Space] Both parts empty, skipping');
                            return;
                        }

                        // Remove the current editable span first
                        const insertPosition = container.nextSibling;
                        container.remove();

                        let lastInserted = null;

                        // Create chip for text before cursor if it exists and not just punctuation
                        if (beforeCursor && /[\p{L}\p{N}]/u.test(beforeCursor)) {
                            console.log('[Space] Creating chip for beforeCursor:', beforeCursor);
                            let error = null;
                            if (element === starterWords) {
                                const availableLetters = getTextContent(targetLetters, false);
                                error = validateWord(beforeCursor, availableLetters, element);
                            }
                            const chip = createChip(beforeCursor, true, error);
                            if (insertPosition) {
                                element.insertBefore(chip, insertPosition);
                            } else {
                                element.appendChild(chip);
                            }
                            lastInserted = chip;
                        }

                        // Create chip for text after cursor if it exists and not just punctuation
                        if (afterCursor && /[\p{L}\p{N}]/u.test(afterCursor)) {
                            console.log('[Space] Creating chip for afterCursor:', afterCursor);
                            let error = null;
                            if (element === starterWords) {
                                const availableLetters = getTextContent(targetLetters, false);
                                error = validateWord(afterCursor, availableLetters, element);
                            }
                            const chip = createChip(afterCursor, true, error);
                            if (lastInserted) {
                                element.insertBefore(chip, lastInserted.nextSibling);
                            } else if (insertPosition) {
                                element.insertBefore(chip, insertPosition);
                            } else {
                                element.appendChild(chip);
                            }
                            lastInserted = chip;
                        } else if (afterCursor) {
                            console.log('[Space] Skipping afterCursor (punctuation only):', afterCursor);
                        }

                        // Create new empty editable span after all chips
                        const newSpan = document.createElement('span');
                        newSpan.className = 'editable-span';
                        newSpan.contentEditable = 'true';
                        newSpan.textContent = '\u200B';

                        if (lastInserted) {
                            element.insertBefore(newSpan, lastInserted.nextSibling);
                        } else if (insertPosition) {
                            element.insertBefore(newSpan, insertPosition);
                        } else {
                            element.appendChild(newSpan);
                        }

                        // Ensure there's also one at the end
                        ensureEditableSpace(element);

                        // Focus the new editable span right after the chip
                        newSpan.focus();
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(newSpan, 0);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);

                        saveState();
                        checkAndTriggerSolve();
                    }
                }

                // Handle backspace to convert chip back to editable span
                if (e.key === 'Backspace') {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;

                    // If we're in a text node, get the parent
                    if (container.nodeType === Node.TEXT_NODE) {
                        container = container.parentElement;
                    }

                    // Check if we're at the start of an editable span
                    if (container.classList && container.classList.contains('editable-span')) {
                        const textContent = container.textContent.replace(/\u200B/g, '');
                        if (!textContent || range.startOffset === 0) {
                            const prevSibling = container.previousSibling;
                            if (prevSibling && prevSibling.classList && prevSibling.classList.contains('word-chip')) {
                                e.preventDefault();

                                // Get the chip's text and convert it back to editable span
                                const chipText = prevSibling.dataset.text || '';

                                // Create new editable span with the chip's text minus last character
                                // Use Array.from to properly handle multi-byte Unicode characters
                                const chars = Array.from(chipText);
                                const newText = chars.slice(0, -1).join('');
                                const newSpan = document.createElement('span');
                                newSpan.className = 'editable-span';
                                newSpan.contentEditable = 'true';
                                newSpan.textContent = newText || '\u200B';

                                // Replace the chip with the new editable span
                                element.insertBefore(newSpan, prevSibling);
                                prevSibling.remove();

                                // Remove the current empty editable span (the one we were in)
                                container.remove();

                                // Ensure there's still an editable span at the end
                                ensureEditableSpace(element);

                                // Focus at the end of the new span
                                newSpan.focus();
                                const newRange = document.createRange();
                                const sel = window.getSelection();
                                newRange.selectNodeContents(newSpan);
                                newRange.collapse(false);
                                sel.removeAllRanges();
                                sel.addRange(newRange);

                                // Revalidate if this is solve words
                                if (element === starterWords) {
                                    const availableLetters = getTextContent(targetLetters, false);
                                    revalidateChips(starterWords, availableLetters);
                                }

                                saveState();
                                checkAndTriggerSolve();
                            }
                        }
                    }
                }

                // Handle arrow keys to navigate between editable spans
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;

                    // If we're in a text node, get the parent
                    if (container.nodeType === Node.TEXT_NODE) {
                        container = container.parentElement;
                    }

                    // Check if we're in an editable span
                    if (container.classList && container.classList.contains('editable-span')) {
                        const text = container.textContent.replace(/\u200B/g, '');
                        const cursorPos = range.startOffset;

                        // Arrow left at the beginning of span - jump to previous editable span or chip
                        if (e.key === 'ArrowLeft' && cursorPos === 0) {
                            let prev = container.previousSibling;

                            // Skip whitespace text nodes
                            while (prev && prev.nodeType === Node.TEXT_NODE) {
                                prev = prev.previousSibling;
                            }

                            if (prev) {
                                e.preventDefault();
                                if (prev.classList.contains('editable-span')) {
                                    // Jump to previous editable span
                                    prev.focus();
                                    const newRange = document.createRange();
                                    const sel = window.getSelection();
                                    newRange.selectNodeContents(prev);
                                    newRange.collapse(false); // End of span
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);
                                } else if (prev.classList.contains('word-chip')) {
                                    // Convert current span to chip if it has text with letters/numbers
                                    const trimmedText = text.trim();
                                    if (trimmedText && /[\p{L}\p{N}]/u.test(trimmedText)) {
                                        console.log('[ArrowLeft] Creating chip for text:', trimmedText);
                                        let error = null;
                                        if (element === starterWords) {
                                            const availableLetters = getTextContent(targetLetters, false);
                                            error = validateWord(trimmedText, availableLetters, element);
                                        }
                                        const chip = createChip(trimmedText, true, error);
                                        element.insertBefore(chip, container);
                                        container.remove();
                                    } else {
                                        if (trimmedText) {
                                            console.log('[ArrowLeft] Skipping chip creation (punctuation only):', trimmedText);
                                        }
                                        container.remove();
                                    }

                                    // Convert previous chip to editable span
                                    const chipText = prev.dataset.text || '';
                                    const newSpan = document.createElement('span');
                                    newSpan.className = 'editable-span';
                                    newSpan.contentEditable = 'true';
                                    newSpan.textContent = chipText;

                                    element.insertBefore(newSpan, prev);
                                    prev.remove();

                                    ensureEditableSpace(element);

                                    // Focus at end of new span
                                    newSpan.focus();
                                    const newRange = document.createRange();
                                    const sel = window.getSelection();
                                    newRange.selectNodeContents(newSpan);
                                    newRange.collapse(false);
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);

                                    if (element === starterWords) {
                                        const availableLetters = getTextContent(targetLetters, false);
                                        revalidateChips(starterWords, availableLetters);
                                    }

                                    saveState();
                                    checkAndTriggerSolve();
                                }
                            }
                        }

                        // Arrow right at the end of span - jump to next editable span or chip
                        if (e.key === 'ArrowRight' && cursorPos >= text.length) {
                            let next = container.nextSibling;

                            // Skip whitespace text nodes
                            while (next && next.nodeType === Node.TEXT_NODE) {
                                next = next.nextSibling;
                            }

                            if (next) {
                                e.preventDefault();
                                if (next.classList.contains('editable-span')) {
                                    // Jump to next editable span
                                    next.focus();
                                    const newRange = document.createRange();
                                    const sel = window.getSelection();
                                    newRange.selectNodeContents(next);
                                    newRange.collapse(true); // Start of span
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);
                                } else if (next.classList.contains('word-chip')) {
                                    // Convert current span to chip if it has text with letters/numbers
                                    const trimmedText = text.trim();
                                    if (trimmedText && /[\p{L}\p{N}]/u.test(trimmedText)) {
                                        console.log('[ArrowRight] Creating chip for text:', trimmedText);
                                        let error = null;
                                        if (element === starterWords) {
                                            const availableLetters = getTextContent(targetLetters, false);
                                            error = validateWord(trimmedText, availableLetters, element);
                                        }
                                        const chip = createChip(trimmedText, true, error);
                                        element.insertBefore(chip, container);
                                        container.remove();
                                    } else {
                                        if (trimmedText) {
                                            console.log('[ArrowRight] Skipping chip creation (punctuation only):', trimmedText);
                                        }
                                        container.remove();
                                    }

                                    // Convert next chip to editable span
                                    const chipText = next.dataset.text || '';
                                    const newSpan = document.createElement('span');
                                    newSpan.className = 'editable-span';
                                    newSpan.contentEditable = 'true';
                                    newSpan.textContent = chipText;

                                    element.insertBefore(newSpan, next);
                                    next.remove();

                                    ensureEditableSpace(element);

                                    // Focus at start of new span
                                    newSpan.focus();
                                    const newRange = document.createRange();
                                    const sel = window.getSelection();
                                    newRange.selectNodeContents(newSpan);
                                    newRange.collapse(true);
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);

                                    if (element === starterWords) {
                                        const availableLetters = getTextContent(targetLetters, false);
                                        revalidateChips(starterWords, availableLetters);
                                    }

                                    saveState();
                                    checkAndTriggerSolve();
                                }
                            }
                        }
                    }
                }
            });

            // Convert any remaining text to chips on blur
            element.addEventListener('blur', (e) => {
                // Don't process if we're focusing another editable span in the same container
                if (e.relatedTarget && element.contains(e.relatedTarget)) {
                    return;
                }

                // Find all editable spans with content
                const spans = element.querySelectorAll('.editable-span');
                spans.forEach(span => {
                    const text = span.textContent.replace(/\u200B/g, '').trim();
                    if (text) {
                        const words = text.split(separator).filter(w => w);
                        words.forEach(word => {
                            // Only create chip if word contains letters or numbers (not just punctuation)
                            if (/[\p{L}\p{N}]/u.test(word)) {
                                console.log('[Blur] Creating chip for word:', word);
                                // Validate chip (only for solve words)
                                let error = null;
                                if (element === starterWords) {
                                    const availableLetters = getTextContent(targetLetters, false);
                                    error = validateWord(word, availableLetters, element);
                                }
                                const chip = createChip(word, true, error);
                                element.insertBefore(chip, span);
                            } else {
                                console.log('[Blur] Skipping word (punctuation only):', word);
                            }
                        });
                        span.textContent = '\u200B'; // Reset span
                    }
                });

                saveState();
                checkAndTriggerSolve();
            });

            // Track dragged chip and insertion marker
            let draggedChip = null;
            let insertionMarker = null;

            // Setup drop zones with insertion preview
            element.addEventListener('dragover', (e) => {
                e.preventDefault();
                const allowMove = e.dataTransfer.types.includes('allow-move');
                e.dataTransfer.dropEffect = allowMove ? 'move' : 'copy';
                element.style.borderColor = '#667eea';

                // Find the chip we're hovering over
                const afterElement = getDragAfterElement(element, e.clientX);
                const draggingElement = document.querySelector('.dragging');

                if (draggingElement && draggingElement.classList.contains('word-chip')) {
                    // Show where it will be inserted
                    if (afterElement == null) {
                        // Append at the end (before the last editable span)
                        const editableSpans = element.querySelectorAll('.editable-span');
                        const lastEditableSpan = editableSpans[editableSpans.length - 1];
                        if (lastEditableSpan) {
                            element.insertBefore(draggingElement, lastEditableSpan);
                        }
                    } else {
                        element.insertBefore(draggingElement, afterElement);
                    }
                }
            });

            element.addEventListener('dragleave', (e) => {
                // Only remove border if leaving the element entirely
                if (!element.contains(e.relatedTarget)) {
                    element.style.borderColor = '';
                }
            });

            element.addEventListener('drop', (e) => {
                e.preventDefault();
                element.style.borderColor = '';

                const word = e.dataTransfer.getData('text/plain');
                const allowMove = e.dataTransfer.getData('allow-move') === 'true';
                const chipId = e.dataTransfer.getData('chip-id');
                console.log('[Drop] Received:', word, 'allowMove:', allowMove, 'chipId:', chipId, 'in element:', element.id);

                // Check if we're dropping a chip that's already in this element (reorder)
                const existingChip = element.querySelector(`[data-chip-id="${chipId}"]`);
                if (existingChip && allowMove) {
                    console.log('[Drop] Reordering existing chip within same element');
                    // Already moved during dragover, just clean up
                    ensureEditableSpace(element);
                    saveState();
                    checkAndTriggerSolve();
                } else if (word && !existingChip) {
                    // New chip from elsewhere - validate it (only for solve words)
                    let error = null;
                    if (element === starterWords) {
                        const availableLetters = getTextContent(targetLetters, false);
                        error = validateWord(word, availableLetters, element);
                    }

                    const afterElement = getDragAfterElement(element, e.clientX);
                    const chip = createChip(word, true, error);

                    if (afterElement == null) {
                        // Insert before the last editable span
                        const editableSpans = element.querySelectorAll('.editable-span');
                        const lastEditableSpan = editableSpans[editableSpans.length - 1];
                        if (lastEditableSpan) {
                            element.insertBefore(chip, lastEditableSpan);
                        } else {
                            element.appendChild(chip);
                        }
                    } else {
                        element.insertBefore(chip, afterElement);
                    }

                    ensureEditableSpace(element);
                    saveState();
                    checkAndTriggerSolve();
                }
            });

            // Helper to find which chip we're dragging after
            function getDragAfterElement(container, x) {
                const draggableElements = [...container.querySelectorAll('.word-chip:not(.dragging)')];

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
        }

        // Setup all editable inputs
        setupEditableInput(targetLetters, '');
        setupEditableInput(starterWords);
        setupEditableInput(excludeWords);

        // Web Worker for background solving
        let solverWorker = null;
        let workerReady = false;

        // Auto-load dictionary on page load
        (async function loadDictionary() {
            try {
                const response = await fetch('readlex/readlex.json');
                if (!response.ok) {
                    throw new Error(`Failed to load: ${response.statusText}`);
                }
                const data = await response.json();

                // Initialize main thread solver (for fallback)
                solver = new PangramSolver(data);

                // Initialize Web Worker
                solverWorker = new Worker('pangram-worker.js');

                // Setup worker message handlers
                function setupWorkerHandlers() {
                    solverWorker.onmessage = function(e) {
                    const { type, data: msgData } = e.data;

                    if (type === 'ready') {
                        workerReady = true;
                        console.log('[Worker] Initialized and ready');

                        // Load saved state after dictionary is loaded
                        loadState();

                        // Trigger initial solve
                        triggerSolve();
                    } else if (type === 'solution') {
                        // Solution found in worker
                        const { solution, count } = msgData;
                        allSolutions.push(solution);

                        // Check if this is an exact match
                        const hasExactMatch = currentParams && currentParams.letters === '';

                        // For regular searches, display immediately
                        // For exact matches, wait for finishBatch to display prominently
                        if (!hasExactMatch) {
                            displaySolution(solution, allSolutions.length - 1);
                        }

                        // Update count
                        totalSolutionsFound = allSolutions.length;
                        if (hasExactMatch) {
                            solutionCountEl.textContent = `${totalSolutionsFound} (exact match!)`;
                        } else {
                            solutionCountEl.textContent = `>${totalSolutionsFound}`;
                        }
                    } else if (type === 'complete') {
                        console.log('[Worker] Search complete, found', msgData.totalSolutions, 'solutions');
                        finishBatch(msgData.totalSolutions);
                    } else if (type === 'error') {
                        console.error('[Worker] Error:', msgData.error);
                        finishBatch(0);
                    }
                };

                    solverWorker.onerror = function(err) {
                        console.error('[Worker] Unexpected error:', err);
                        workerReady = false;
                    };
                }

                setupWorkerHandlers();

                // Send dictionary to worker
                solverWorker.postMessage({
                    type: 'init',
                    data: { dictionary: data }
                });
            } catch (err) {
                console.error('Error loading dictionary:', err);
                alert(`Error loading dictionary: ${err.message}`);
            }
        })();

        // Auto-solve when inputs change
        let solveTimeout = null;
        function triggerSolve() {
            if (!solver) {
                return;
            }

            // Debounce - wait 500ms after last change
            if (solveTimeout) {
                clearTimeout(solveTimeout);
            }

            solveTimeout = setTimeout(() => {
                startFreshSearch();
            }, 500);
        }

        function startFreshSearch() {
            // Terminate any existing worker search
            if (solverWorker && workerReady && isLoadingMore) {
                console.log('[Worker] Terminating previous search');
                solverWorker.terminate();

                // Recreate worker
                solverWorker = new Worker('pangram-worker.js');
                workerReady = false;

                // Re-setup message handlers
                setupWorkerHandlers();

                // Re-initialize with dictionary data
                fetch('readlex/readlex.json')
                    .then(r => r.json())
                    .then(data => {
                        solverWorker.postMessage({
                            type: 'init',
                            data: { dictionary: data }
                        });
                    });
            }

            // Start fresh
            allSolutions = [];
            displayedCount = 0;
            totalSolutionsFound = 0;
            resultsContainer.innerHTML = '';
            isLoadingMore = false;

            // Show searching state (don't show 0)
            solutionCountEl.textContent = '...';

            // Get parameters from contenteditable elements
            // Strip punctuation for search purposes
            let letters = getTextContent(targetLetters, true).trim();
            const starters = getTextContent(starterWords, true).trim();
            const exclude = getTextContent(excludeWords, true).trim();

            // Check for errors in input chips and collect error messages
            const errorChips = document.querySelectorAll('.word-chip.error');
            if (errorChips.length > 0) {
                const errorMessages = new Set();
                errorChips.forEach(chip => {
                    if (chip.title) {
                        errorMessages.add(chip.title);
                    }
                });

                const errorList = Array.from(errorMessages).map(msg => `‚Ä¢ ${msg}`).join('<br>');
                resultsContainer.innerHTML = `<div class="no-results"><strong>Cannot solve - please fix these errors:</strong><br><br>${errorList}</div>`;
                solutionCountEl.textContent = '0';
                return;
            }

            // Remove all whitespace from letters
            if (letters) {
                letters = letters.replace(/\s+/g, '');
            }

            // If no target letters specified, use null to signal "use all letters"
            if (!letters && !starters) {
                letters = null;
            }

            // Process starter words
            if (starters) {
                const starterLetters = starters.replace(/\s+/g, '');
                if (!letters) {
                    // Default to all letters for current alphabet
                    const alphabet = getCurrentAlphabet();
                    if (alphabet === 'roman') {
                        letters = 'abcdefghijklmnopqrstuvwxyz';
                    } else {
                        // All 48 Shavian letters
                        letters = '';
                        for (let i = 0x10450; i < 0x10480; i++) {
                            letters += String.fromCodePoint(i);
                        }
                    }
                }

                // Remove starter word letters from target
                const letterCounts = new Map();
                for (const letter of letters) {
                    letterCounts.set(letter, (letterCounts.get(letter) || 0) + 1);
                }

                for (const letter of starterLetters) {
                    if ((letterCounts.get(letter) || 0) > 0) {
                        letterCounts.set(letter, letterCounts.get(letter) - 1);
                    } else {
                        // Invalid starter words - show error
                        resultsContainer.innerHTML = '<div class="no-results">Error: Solve words use letters not available in target letters.</div>';
                        solutionCountEl.textContent = '0';
                        return;
                    }
                }

                // Rebuild letters from counter
                letters = '';
                for (const [letter, count] of letterCounts) {
                    if (count > 0) {
                        letters += letter.repeat(count);
                    }
                }
            }

            // Process exclusions
            const excludeWordsSet = exclude ?
                new Set(exclude.replace(/,/g, ' ').split(/\s+/).filter(w => w)) :
                new Set();

            // Store parameters for infinite scroll
            currentParams = {
                letters: letters,
                excludeWordsSet: excludeWordsSet,
                alphabet: getCurrentAlphabet()
            };

            // Run first batch
            runBatch(0);
        }

        // Update hint text when alphabet changes
        function updateAlphabetHint() {
            const alphabet = getCurrentAlphabet();
            if (alphabet === 'roman') {
                targetLettersHint.textContent = '(leave empty for all 26 Roman letters, click to remove)';
                targetLetters.setAttribute('data-placeholder', 'abc or leave empty');
            } else {
                targetLettersHint.textContent = '(leave empty for all 48 Shavian letters, click to remove)';
                targetLetters.setAttribute('data-placeholder', 'êëêêëëêëíêëìêëîêëï or leave empty');
            }
        }

        // Switch alphabet - save current state and load new alphabet's state
        function switchAlphabet() {
            // Get the OLD alphabet before the radio button changed
            const oldAlphabet = alphabetRoman.checked ? 'shavian' : 'roman';

            // Save state for OLD alphabet
            const oldKeys = getStorageKeys(oldAlphabet);
            localStorage.setItem(oldKeys.targetLetters, getTextContent(targetLetters));
            localStorage.setItem(oldKeys.starterWords, getTextContent(starterWords));
            localStorage.setItem(oldKeys.excludeWords, getTextContent(excludeWords));
            localStorage.setItem(ALPHABET_KEY, getCurrentAlphabet());

            // Update hint
            updateAlphabetHint();

            // Load state for NEW alphabet
            const newAlphabet = getCurrentAlphabet();
            const keys = getStorageKeys(newAlphabet);
            const targetText = localStorage.getItem(keys.targetLetters) || '';
            const starterText = localStorage.getItem(keys.starterWords) || '';
            const excludeText = localStorage.getItem(keys.excludeWords) || '';

            // Clear current fields
            targetLetters.innerHTML = '';
            starterWords.innerHTML = '';
            excludeWords.innerHTML = '';

            // Load saved state for new alphabet
            // Target letters is plain text, not chips
            if (targetText) {
                targetLetters.textContent = targetText;
            }
            if (starterText) setTextContent(starterWords, starterText);
            if (excludeText) setTextContent(excludeWords, excludeText);

            // Ensure editable spaces
            ensureEditableSpace(targetLetters);
            ensureEditableSpace(starterWords);
            ensureEditableSpace(excludeWords);

            // Validate and solve (only solve words need validation)
            const availableLetters = getTextContent(targetLetters, false);
            revalidateChips(starterWords, availableLetters);

            triggerSolve();
        }

        // Alphabet change triggers switch
        alphabetShavian.addEventListener('change', switchAlphabet);
        alphabetRoman.addEventListener('change', switchAlphabet);

        // Trigger solve on input changes (after typing stops)
        targetLetters.addEventListener('input', triggerSolve);
        excludeWords.addEventListener('input', triggerSolve);

        function runBatch(skipCount) {
            if (!currentParams) {
                return;
            }

            if (!workerReady) {
                console.log('[Worker] Not ready yet, waiting...');
                // Retry after worker is ready
                setTimeout(() => runBatch(skipCount), 100);
                return;
            }

            if (isLoadingMore) {
                console.log('[Worker] Already searching, ignoring request');
                return;
            }

            isLoadingMore = true;

            // Show loading indicator when loading more (not initial batch)
            if (skipCount > 0) {
                loadingIndicator.style.display = 'block';
            }

            // Pass the letters as-is. Empty string means no letters left (exact match).
            // null means use all letters for the current alphabet.
            const lettersToSolve = currentParams.letters === '' ? '' : currentParams.letters;

            console.log('[Worker] Starting search:', {
                letters: lettersToSolve ? lettersToSolve.substring(0, 20) + '...' : 'all',
                letterCount: lettersToSolve ? lettersToSolve.length : 'all',
                skipCount,
                maxSolutions: BATCH_SIZE,
                alphabet: currentParams.alphabet
            });

            // Send solve request to worker
            solverWorker.postMessage({
                type: 'solve',
                data: {
                    targetLetters: lettersToSolve,
                    maxSolutions: BATCH_SIZE,
                    excludeWords: currentParams.excludeWordsSet,
                    excludePos: new Set(),
                    skipSolutions: skipCount,
                    alphabet: currentParams.alphabet
                }
            });
        }

        let isLoadingMore = false;
        let hasMoreSolutions = false;

        function finishBatch(foundCount) {
            isLoadingMore = false;

            // Check if we have an exact match (no remaining letters)
            const hasExactMatch = currentParams && currentParams.letters === '';

            // For exact matches, there can only be one solution per word combination
            // So stop after first batch even if we found BATCH_SIZE solutions
            if (hasExactMatch) {
                hasMoreSolutions = false;
                // Show exact match actions
                exactMatchActions.classList.remove('hidden');
                // Update save button state
                updateSaveButtonState();

                // Display the exact match prominently
                // Get starter words WITH punctuation preserved
                const startersWithPunctuation = getTextContent(starterWords, false).trim().split(/[\s,]+/).filter(w => w);

                // Display as single prominent solution
                resultsContainer.innerHTML = '';
                displayExactMatch(startersWithPunctuation);
            } else {
                hasMoreSolutions = foundCount === BATCH_SIZE;
                // Hide exact match actions
                exactMatchActions.classList.add('hidden');
            }

            // Hide loading indicator
            loadingIndicator.style.display = 'none';

            // Update solution count display
            if (hasMoreSolutions) {
                solutionCountEl.textContent = `>${totalSolutionsFound}`;
            } else {
                solutionCountEl.textContent = `${totalSolutionsFound}${hasExactMatch ? ' (exact match!)' : ''}`;
            }

            if (allSolutions.length === 0 && foundCount === 0) {
                resultsContainer.innerHTML = '<div class="no-results">No solutions found</div>';
                currentParams = null; // Reset
                solutionCountEl.textContent = '0';
                exactMatchActions.classList.add('hidden');
            } else if (foundCount < BATCH_SIZE) {
                // Found fewer than batch size, no more solutions
                if (foundCount === 0) {
                    resultsContainer.innerHTML += '<div class="no-results">No more solutions found</div>';
                }
                currentParams = null; // Reset
            } else if (hasExactMatch) {
                // Exact match - we're done
                currentParams = null; // Reset to prevent infinite scroll from loading more
            }
        }


        function displayExactMatch(allWords) {
            // Remove placeholder if it exists
            const placeholder = resultsContainer.querySelector('.placeholder');
            if (placeholder) {
                placeholder.remove();
            }

            const div = document.createElement('div');
            div.className = 'result-item exact-match';

            // Add result text with draggable words
            const textSpan = document.createElement('span');
            textSpan.className = 'result-text';

            // All words are starter words for exact match (they use all letters)
            allWords.forEach((word, wordIndex) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'draggable-word starter-word';

                wordSpan.textContent = word;
                wordSpan.draggable = true;
                wordSpan.dataset.word = word;

                // Add drag event listeners to individual words
                wordSpan.addEventListener('dragstart', handleWordDragStart);
                wordSpan.addEventListener('dragend', handleWordDragEnd);

                // Double-click to add to solve words
                wordSpan.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    addWordToSolveWords(word);
                });

                textSpan.appendChild(wordSpan);

                // Add space between words (except for last word)
                if (wordIndex < allWords.length - 1) {
                    textSpan.appendChild(document.createTextNode(' '));
                }
            });

            div.appendChild(textSpan);
            resultsContainer.appendChild(div);
            displayedCount++;
        }

        function displaySolution(solution, index) {
            // Remove placeholder if it exists
            const placeholder = resultsContainer.querySelector('.placeholder');
            if (placeholder) {
                placeholder.remove();
            }

            const div = document.createElement('div');
            div.className = 'result-item';
            div.dataset.index = index;

            // Add result number
            const numberSpan = document.createElement('span');
            numberSpan.className = 'result-number';
            numberSpan.textContent = `${index + 1}.`;
            div.appendChild(numberSpan);

            // Add result text with draggable words
            const textSpan = document.createElement('span');
            textSpan.className = 'result-text';

            // Get starter words WITH punctuation preserved
            const startersWithPunctuation = getTextContent(starterWords, false).trim().split(/[\s,]+/).filter(w => w);

            // Combine starter words (with punctuation) + solution
            const allWords = [...startersWithPunctuation, ...solution];

            // For exact match (empty solution), show a message if no starter words
            if (allWords.length === 0) {
                textSpan.textContent = '(empty solution)';
            }

            allWords.forEach((word, wordIndex) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'draggable-word';

                // Mark starter words differently
                if (wordIndex < startersWithPunctuation.length) {
                    wordSpan.classList.add('starter-word');
                }

                wordSpan.textContent = word;
                wordSpan.draggable = true;
                wordSpan.dataset.word = word;

                // Add drag event listeners to individual words
                wordSpan.addEventListener('dragstart', handleWordDragStart);
                wordSpan.addEventListener('dragend', handleWordDragEnd);

                // Double-click to add to solve words
                wordSpan.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    addWordToSolveWords(word);
                });

                textSpan.appendChild(wordSpan);

                // Add space between words (except for last word)
                if (wordIndex < allWords.length - 1) {
                    textSpan.appendChild(document.createTextNode(' '));
                }
            });

            div.appendChild(textSpan);
            resultsContainer.appendChild(div);
            displayedCount++;
        }

        function displayNextBatch() {
            const end = Math.min(displayedCount + BATCH_SIZE, allSolutions.length);

            for (let i = displayedCount; i < end; i++) {
                displaySolution(allSolutions[i], i);
            }
        }

        // Drag and drop functionality for individual words in results
        let draggedWord = null;

        function handleWordDragStart(e) {
            draggedWord = this.dataset.word;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', this.dataset.word);
            e.dataTransfer.setData('allow-move', 'false'); // Results are copy-only
            console.log('[Drag] Result word start:', this.dataset.word);
        }

        function handleWordDragEnd(e) {
            this.classList.remove('dragging');
            console.log('[Drag] Result word end:', draggedWord);
        }

        // Add word to solve words
        function addWordToSolveWords(word) {
            // Check if word already exists
            const existingChips = starterWords.querySelectorAll('.word-chip');
            const { core: wordCore } = extractPunctuation(word);

            for (const chip of existingChips) {
                const chipText = chip.dataset.text || '';
                const { core: chipCore } = extractPunctuation(chipText);
                if (chipCore === wordCore) {
                    // Already exists, flash it
                    chip.style.background = '#667eea';
                    chip.style.color = 'white';
                    setTimeout(() => {
                        chip.style.background = '';
                        chip.style.color = '';
                    }, 300);
                    return;
                }
            }

            // Add new chip at the end (before the last editable span)
            const availableLetters = getTextContent(targetLetters, false);
            const error = validateWord(word, availableLetters, starterWords);
            const chip = createChip(word, true, error);

            const editableSpans = starterWords.querySelectorAll('.editable-span');
            const lastEditableSpan = editableSpans[editableSpans.length - 1];
            if (lastEditableSpan) {
                starterWords.insertBefore(chip, lastEditableSpan);
            } else {
                starterWords.appendChild(chip);
                ensureEditableSpace(starterWords);
            }

            saveState();
            checkAndTriggerSolve();
        }

        // Track previous values for change detection
        let previousValues = {
            targetLetters: '',
            starterWords: '',
            excludeWords: ''
        };

        // Revalidate all chips in an element
        function revalidateChips(element, availableLetters) {
            const chips = element.querySelectorAll('.word-chip');

            // First pass: collect all words to check for duplicates properly
            const wordsMap = new Map();
            chips.forEach((chip, index) => {
                const text = chip.dataset.text;
                const { core } = extractPunctuation(text);
                if (!wordsMap.has(core)) {
                    wordsMap.set(core, []);
                }
                wordsMap.get(core).push(index);
            });

            // Second pass: validate each chip
            chips.forEach((chip, index) => {
                const text = chip.dataset.text;
                const { core } = extractPunctuation(text);
                let error = null;

                // Check for duplicates
                const indices = wordsMap.get(core);
                if (indices && indices.length > 1) {
                    error = `Duplicate word: '${core}'`;
                } else {
                    // Check letter availability
                    error = validateWord(text, availableLetters, null);
                }

                if (error) {
                    chip.classList.add('error');
                    chip.title = error;
                } else {
                    chip.classList.remove('error');
                    chip.title = '';
                }
            });
        }

        // Check if values actually changed and trigger solve
        function checkAndTriggerSolve() {
            // Compare stripped values (without punctuation) for search purposes
            const currentValues = {
                targetLetters: getTextContent(targetLetters, true),
                starterWords: getTextContent(starterWords, true),
                excludeWords: getTextContent(excludeWords, true)
            };

            if (currentValues.targetLetters !== previousValues.targetLetters ||
                currentValues.starterWords !== previousValues.starterWords ||
                currentValues.excludeWords !== previousValues.excludeWords) {

                // If target letters changed, revalidate starter words
                if (currentValues.targetLetters !== previousValues.targetLetters) {
                    // Revalidate solve words when target letters change
                    const availableLetters = getTextContent(targetLetters, false);
                    revalidateChips(starterWords, availableLetters);
                }

                previousValues = currentValues;
                triggerSolve();
            }
        }

        // Infinite scroll - both for displaying existing results and loading new ones
        resultsContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = resultsContainer;

            // If scrolled near bottom
            if (scrollHeight - scrollTop - clientHeight < 100) {
                // First, display any already-loaded solutions
                if (displayedCount < allSolutions.length) {
                    displayNextBatch();
                }
                // Then, if we've displayed all current solutions and there are more available, load them
                else if (hasMoreSolutions && !isLoadingMore && currentParams) {
                    runBatch(totalSolutionsFound);
                }
            }
        });

        // Initial display
        if (displayedCount < allSolutions.length) {
            displayNextBatch();
        }

        // ========================================
        // Burger Menu and Dialogs
        // ========================================

        const burgerMenu = document.getElementById('burger-menu');
        const menuDropdown = document.getElementById('menu-dropdown');
        const menuAbout = document.getElementById('menu-about');
        const menuSolutions = document.getElementById('menu-solutions');
        const menuShare = document.getElementById('menu-share');
        const aboutDialog = document.getElementById('about-dialog');
        const solutionsDialog = document.getElementById('solutions-dialog');
        const aboutContent = document.getElementById('about-content');
        const solutionsList = document.getElementById('solutions-list');
        const saveCurrentBtn = document.getElementById('save-current');

        // Toggle menu dropdown
        burgerMenu.addEventListener('click', (e) => {
            e.stopPropagation();
            menuDropdown.classList.toggle('hidden');
        });

        // Close menu when clicking outside
        document.addEventListener('click', () => {
            menuDropdown.classList.add('hidden');
        });

        // Open About dialog
        menuAbout.addEventListener('click', async () => {
            menuDropdown.classList.add('hidden');

            // Load about.html content
            try {
                const response = await fetch('about.html');
                const html = await response.text();
                aboutContent.innerHTML = html;
            } catch (err) {
                aboutContent.innerHTML = '<p>Failed to load about content.</p>';
            }

            aboutDialog.classList.remove('hidden');
        });

        // Open Solutions dialog
        menuSolutions.addEventListener('click', () => {
            menuDropdown.classList.add('hidden');
            loadSolutions();
            solutionsDialog.classList.remove('hidden');
        });

        // Share current state
        menuShare.addEventListener('click', async () => {
            menuDropdown.classList.add('hidden');

            const state = {
                a: getCurrentAlphabet(),
                t: getTextContent(targetLetters, false),
                s: getTextContent(starterWords, false),
                e: getTextContent(excludeWords, false)
            };

            // Build URL with state
            const url = new URL(window.location.href);
            url.search = ''; // Clear existing params
            if (state.a !== 'shavian') url.searchParams.set('a', state.a);
            if (state.t) url.searchParams.set('t', state.t);
            if (state.s) url.searchParams.set('s', state.s);
            if (state.e) url.searchParams.set('e', state.e);

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(url.toString());
                alert('Share link copied to clipboard!');
            } catch (err) {
                // Fallback for browsers that don't support clipboard API
                prompt('Copy this link to share:', url.toString());
            }
        });

        // Close dialogs
        document.querySelectorAll('.dialog-close').forEach(btn => {
            btn.addEventListener('click', () => {
                aboutDialog.classList.add('hidden');
                solutionsDialog.classList.add('hidden');
            });
        });

        // Close dialog when clicking overlay
        [aboutDialog, solutionsDialog].forEach(dialog => {
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    dialog.classList.add('hidden');
                }
            });
        });

        // ========================================
        // Solutions Management
        // ========================================

        const SOLUTIONS_KEY = 'saved-solutions';
        const DEFAULT_SOLUTIONS = [
            {
                alphabet: 'shavian',
                target: '',
                solveWords: 'êë£êëΩêë¶êëô êë•êë∞ êëöêë¥, êëû êë®êë†êëº êëîêëÆêë≥êëñ êëíêë∑êëü. êë∫ êëòêëπ êë°êë∂êëìêë©êë§ êë∏êëæ, êë≤ êëùêë¨, "êëø êë¢êë™êëØêëë êëúêë´êëõ êëóêë≠. êëßêëïêë± êëêêëµ-êëª!".',
                excludeWords: ''
            },
            {
                alphabet: 'shavian',
                target: '',
                solveWords: 'êë¥ êëòêëßêë©; êë•êë≠, êë£êë®êëù êë°êë∂ êë¶êëì êëîêë™êëô êë∫êëæêëü êë∏ êëöêë≤ êëÆêëµêë† êë¢êë∑êëëêëº: êëû êëúêë± êë¨êë§, êëñêë∞ êëíêë´êëõ êëêêëªêëó êëØêëΩ êëø êëπ êë≥êëï.',
                excludeWords: ''
            },
            {
                alphabet: 'shavian',
                target: '',
                solveWords: 'êë®êëü êëöêë∂, êëúêëªêë§ êë£êëΩ êëõêë≥êëó ¬∑êëòêë´êëºêë¥êëùêë¶êë†êë©êëØ êëïêë™êëô êë∫: êë∑, êëøêëìêëπêëæ!  "êë•êë≠!" êëûêë± êëñêë¨êëë.  êëíêë∏ êëîêëÆêëµ êëßêë°.  êë≤ êë¢êë∞êëê.',
                excludeWords: ''
            }
        ];

        // Initialize solutions in localStorage if not present
        function initializeSolutions() {
            const saved = localStorage.getItem(SOLUTIONS_KEY);
            if (!saved) {
                localStorage.setItem(SOLUTIONS_KEY, JSON.stringify(DEFAULT_SOLUTIONS));
            }
        }

        // Get all saved solutions
        function getSavedSolutions() {
            const saved = localStorage.getItem(SOLUTIONS_KEY);
            return saved ? JSON.parse(saved) : DEFAULT_SOLUTIONS;
        }

        // Save solutions to localStorage
        function saveSolutions(solutions) {
            localStorage.setItem(SOLUTIONS_KEY, JSON.stringify(solutions));
        }

        // Load and display solutions
        function loadSolutions() {
            const solutions = getSavedSolutions();
            solutionsList.innerHTML = '';

            if (solutions.length === 0) {
                solutionsList.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 40px;">No saved solutions yet.</p>';
                return;
            }

            solutions.forEach((solution, index) => {
                const item = document.createElement('div');
                item.className = 'solution-item';
                item.draggable = true;
                item.dataset.index = index;

                const text = document.createElement('div');
                text.className = 'solution-text';

                // For exact matches, just show the words
                // For anagrams, show "anagram of: target"
                if (solution.isExactMatch) {
                    text.textContent = solution.solveWords || '(empty)';
                } else {
                    const targetPreview = solution.target ? solution.target.slice(0, 30) + (solution.target.length > 30 ? '...' : '') : 'all letters';
                    text.innerHTML = `<span style="font-size: 0.9em; color: #6c757d;">anagram of:</span> ${targetPreview}`;
                }

                const meta = document.createElement('div');
                meta.className = 'solution-meta';

                // Show solve words in meta for anagrams, or exclude words for exact matches
                if (solution.isExactMatch) {
                    const excludeText = solution.excludeWords ? `Exclude: ${solution.excludeWords.slice(0, 30)}${solution.excludeWords.length > 30 ? '...' : ''}` : '';
                    meta.textContent = excludeText;
                } else {
                    const solveText = solution.solveWords ? `Words: ${solution.solveWords.slice(0, 30)}${solution.solveWords.length > 30 ? '...' : ''}` : 'No words';
                    meta.textContent = solveText;
                }

                const removeBtn = document.createElement('button');
                removeBtn.className = 'solution-remove';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeSolution(index);
                });

                // Click to load solution
                item.addEventListener('click', () => {
                    loadSolutionToForm(solution);
                    solutionsDialog.classList.add('hidden');
                });

                // Drag and drop for reordering
                item.addEventListener('dragstart', handleSolutionDragStart);
                item.addEventListener('dragend', handleSolutionDragEnd);
                item.addEventListener('dragover', handleSolutionDragOver);
                item.addEventListener('drop', handleSolutionDrop);

                item.appendChild(text);
                item.appendChild(meta);
                item.appendChild(removeBtn);
                solutionsList.appendChild(item);
            });
        }

        // Load solution into form
        function loadSolutionToForm(solution) {
            // Clear existing content
            targetLetters.innerHTML = '';
            starterWords.innerHTML = '';
            excludeWords.innerHTML = '';

            // Set alphabet
            const alphabet = solution.alphabet || 'shavian';
            if (alphabet === 'roman') {
                alphabetRoman.checked = true;
            } else {
                alphabetShavian.checked = true;
            }
            updateAlphabetHint();

            // Load target letters
            if (solution.target) {
                const letters = solution.target.split('');
                letters.forEach(letter => {
                    if (letter.trim()) {
                        const chip = createChip(letter, true);
                        targetLetters.appendChild(chip);
                    }
                });
            }
            ensureEditableSpace(targetLetters);

            // Load solve words
            if (solution.solveWords) {
                const words = solution.solveWords.split(/[\s,]+/).filter(w => w);
                words.forEach(word => {
                    const chip = createChip(word, true);
                    starterWords.appendChild(chip);
                });
            }
            ensureEditableSpace(starterWords);

            // Load exclude words
            if (solution.excludeWords) {
                const words = solution.excludeWords.split(/[\s,]+/).filter(w => w);
                words.forEach(word => {
                    const chip = createChip(word, true);
                    excludeWords.appendChild(chip);
                });
            }
            ensureEditableSpace(excludeWords);

            // Trigger solve
            checkAndTriggerSolve();
        }

        // Save current solution
        saveCurrentBtn.addEventListener('click', () => {
            const target = getTextContent(targetLetters, false);
            const solution = {
                alphabet: getCurrentAlphabet(),
                target: target,
                solveWords: getTextContent(starterWords, false),
                excludeWords: getTextContent(excludeWords, false),
                isExactMatch: !target || target.trim() === ''  // Exact match if no target letters
            };

            const solutions = getSavedSolutions();
            solutions.push(solution);
            saveSolutions(solutions);
            loadSolutions();
        });

        // Remove solution
        function removeSolution(index) {
            const solutions = getSavedSolutions();
            solutions.splice(index, 1);
            saveSolutions(solutions);
            loadSolutions();
        }

        // Drag and drop for solution reordering
        let draggedSolutionIndex = null;

        function handleSolutionDragStart(e) {
            draggedSolutionIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleSolutionDragEnd(e) {
            this.classList.remove('dragging');
        }

        function handleSolutionDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const afterElement = getDragAfterElementVertical(solutionsList, e.clientY);
            const dragging = solutionsList.querySelector('.dragging');

            if (afterElement == null) {
                solutionsList.appendChild(dragging);
            } else {
                solutionsList.insertBefore(dragging, afterElement);
            }
        }

        function handleSolutionDrop(e) {
            e.preventDefault();

            const dropIndex = parseInt(this.dataset.index);
            if (draggedSolutionIndex === null || draggedSolutionIndex === dropIndex) {
                return;
            }

            // Reorder solutions array
            const solutions = getSavedSolutions();
            const [removed] = solutions.splice(draggedSolutionIndex, 1);

            // Recalculate drop index after removal
            const newDropIndex = draggedSolutionIndex < dropIndex ? dropIndex - 1 : dropIndex;
            solutions.splice(newDropIndex, 0, removed);

            saveSolutions(solutions);
            loadSolutions();
            draggedSolutionIndex = null;
        }

        function getDragAfterElementVertical(container, y) {
            const draggableElements = [...container.querySelectorAll('.solution-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Initialize solutions on load
        initializeSolutions();

        // Global keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check for Cmd (Mac) or Ctrl (Windows/Linux)
            const modifier = e.metaKey || e.ctrlKey;

            if (modifier && e.key === 'z' && !e.shiftKey) {
                // Undo: Cmd+Z or Ctrl+Z
                e.preventDefault();
                if (undoManager.undo()) {
                    console.log('Undo performed');
                }
            } else if (modifier && (e.key === 'Z' || (e.key === 'z' && e.shiftKey))) {
                // Redo: Cmd+Shift+Z or Ctrl+Shift+Z
                e.preventDefault();
                if (undoManager.redo()) {
                    console.log('Redo performed');
                }
            }
        });

        // Take initial snapshot
        setTimeout(() => {
            undoManager.takeSnapshot();
        }, 100);

        // ========================================
        // Exact Match Actions
        // ========================================

        // Check if current pangram is already saved
        function isCurrentPangramSaved() {
            const current = {
                alphabet: getCurrentAlphabet(),
                target: getTextContent(targetLetters, false),
                solveWords: getTextContent(starterWords, false),
                excludeWords: getTextContent(excludeWords, false)
            };

            const solutions = getSavedSolutions();
            return solutions.some(s =>
                s.alphabet === current.alphabet &&
                s.target === current.target &&
                s.solveWords === current.solveWords &&
                s.excludeWords === current.excludeWords
            );
        }

        // Update save button state and text
        function updateSaveButtonState() {
            const hasExactMatch = currentParams && currentParams.letters === '';
            const buttonText = hasExactMatch ? 'üíæ Save This Pangram' : 'üíæ Save This Anagram';

            if (isCurrentPangramSaved()) {
                saveExactMatchBtn.disabled = true;
                saveExactMatchBtn.textContent = '‚úì Already Saved';
                saveExactMatchBtn.style.opacity = '0.6';
                saveExactMatchBtn.style.cursor = 'not-allowed';
            } else {
                saveExactMatchBtn.disabled = false;
                saveExactMatchBtn.textContent = buttonText;
                saveExactMatchBtn.style.opacity = '1';
                saveExactMatchBtn.style.cursor = 'pointer';
            }
        }

        // Save exact match pangram
        saveExactMatchBtn.addEventListener('click', () => {
            if (allSolutions.length === 0 || saveExactMatchBtn.disabled) return;

            const solution = {
                alphabet: getCurrentAlphabet(),
                target: getTextContent(targetLetters, false),
                solveWords: getTextContent(starterWords, false),
                excludeWords: getTextContent(excludeWords, false),
                isExactMatch: true  // Mark as exact match
            };

            const solutions = getSavedSolutions();
            solutions.push(solution);
            saveSolutions(solutions);

            // Update button state
            updateSaveButtonState();

            // Open saved solutions dialog to show the newly saved pangram
            loadSolutions();
            solutionsDialog.classList.remove('hidden');

            // Hide the "Save Current Solution" button in the dialog
            saveCurrentBtn.style.display = 'none';

            // Scroll to bottom to show the new solution
            setTimeout(() => {
                solutionsList.scrollTop = solutionsList.scrollHeight;
                // Restore the button when dialog is closed
                const restoreButton = () => {
                    saveCurrentBtn.style.display = '';
                };
                solutionsDialog.addEventListener('click', function closeHandler(e) {
                    if (e.target === solutionsDialog || e.target.classList.contains('dialog-close')) {
                        restoreButton();
                        solutionsDialog.removeEventListener('click', closeHandler);
                    }
                });
            }, 100);
        });

        // Encode words as compact string using alphabet offsets
        function encodeWords(words, alphabet) {
            if (!words) return '';

            const baseCodepoint = alphabet === 'shavian' ? 0x10450 : 0x61; // 'a'

            return words.split(/\s+/).map(word => {
                let encoded = '';
                for (const char of word) {
                    const codepoint = char.codePointAt(0);
                    // Handle punctuation and special chars (keep as-is with prefix)
                    if (alphabet === 'shavian') {
                        if (codepoint < 0x10450 || codepoint > 0x1047F) {
                            // Non-alphabet char: use _ prefix + 4-digit hex
                            encoded += '_' + codepoint.toString(16).padStart(4, '0');
                        } else {
                            // Alphabet char: 2-digit hex offset (00-2F for 48 letters)
                            encoded += (codepoint - baseCodepoint).toString(16).padStart(2, '0');
                        }
                    } else {
                        if (codepoint < 0x61 || codepoint > 0x7A) { // a-z
                            // Non-alphabet char: use _ prefix + 4-digit hex
                            encoded += '_' + codepoint.toString(16).padStart(4, '0');
                        } else {
                            // Alphabet char: 2-digit hex offset (00-19 for 26 letters)
                            encoded += (codepoint - baseCodepoint).toString(16).padStart(2, '0');
                        }
                    }
                }
                return encoded;
            }).join('-');
        }

        // Decode compact string back to words
        function decodeWords(encoded, alphabet) {
            if (!encoded) return '';

            const baseCodepoint = alphabet === 'shavian' ? 0x10450 : 0x61;

            return encoded.split('-').map(word => {
                let decoded = '';
                let i = 0;
                while (i < word.length) {
                    if (word[i] === '_') {
                        // Non-alphabet char: read 4 hex digits after _
                        const hex = word.substring(i + 1, i + 5);
                        decoded += String.fromCodePoint(parseInt(hex, 16));
                        i += 5;
                    } else {
                        // Alphabet char: read 2 hex digits
                        const hex = word.substring(i, i + 2);
                        decoded += String.fromCodePoint(baseCodepoint + parseInt(hex, 16));
                        i += 2;
                    }
                }
                return decoded;
            }).join(' ');
        }

        // Share exact match or anagram
        shareExactMatchBtn.addEventListener('click', async () => {
            if (allSolutions.length === 0) return;

            const solveWords = getTextContent(starterWords, false);
            const targetText = getTextContent(targetLetters, false);
            const alphabet = getCurrentAlphabet();
            const hasExactMatch = currentParams && currentParams.letters === '';

            // Build URL with state
            const url = new URL(window.location.href);
            url.search = ''; // Clear existing params
            if (alphabet !== 'shavian') url.searchParams.set('a', alphabet);

            if (hasExactMatch) {
                // For exact matches, encode solve words compactly
                const encoded = encodeWords(solveWords, alphabet);
                if (encoded) url.searchParams.set('p', encoded); // 'p' for pangram
            } else {
                // For anagrams, include both target and solve words
                const encodedTarget = encodeWords(targetText, alphabet);
                const encodedSolve = encodeWords(solveWords, alphabet);
                if (encodedTarget) url.searchParams.set('t', encodedTarget); // 't' for target
                if (encodedSolve) url.searchParams.set('s', encodedSolve); // 's' for solve
            }

            // Copy to clipboard and show popup
            try {
                await navigator.clipboard.writeText(url.toString());

                // Show success popup
                const popup = document.createElement('div');
                popup.className = 'share-popup';
                popup.innerHTML = `
                    <div class="share-popup-content">
                        <div class="share-popup-icon">‚úÖ</div>
                        <div class="share-popup-title">Link Copied!</div>
                        <div class="share-popup-url">${url.toString()}</div>
                        <div class="share-popup-message">Share this link to let others view your pangram</div>
                    </div>
                `;
                document.body.appendChild(popup);

                // Animate in
                setTimeout(() => popup.classList.add('show'), 10);

                // Remove after 4 seconds
                setTimeout(() => {
                    popup.classList.remove('show');
                    setTimeout(() => popup.remove(), 300);
                }, 4000);
            } catch (err) {
                // Fallback for browsers that don't support clipboard API
                const fallbackPopup = document.createElement('div');
                fallbackPopup.className = 'share-popup show';
                fallbackPopup.innerHTML = `
                    <div class="share-popup-content">
                        <div class="share-popup-title">Copy this link:</div>
                        <input type="text" value="${url.toString()}" readonly class="share-popup-input" />
                        <button class="share-popup-close">Close</button>
                    </div>
                `;
                document.body.appendChild(fallbackPopup);

                const input = fallbackPopup.querySelector('.share-popup-input');
                input.select();

                fallbackPopup.querySelector('.share-popup-close').addEventListener('click', () => {
                    fallbackPopup.classList.remove('show');
                    setTimeout(() => fallbackPopup.remove(), 300);
                });
            }
        });
    </script>
</body>
</html>
